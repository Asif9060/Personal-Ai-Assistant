#!/usr/bin/env python3\n\"\"\"\nEnhanced TTS implementation for J.A.R.V.I.S\nProvides realistic voice synthesis using multiple backends\n\"\"\"\n\nfrom __future__ import annotations\n\nimport contextlib\nimport time\nfrom typing import Optional, List, Tuple\nimport platform\nimport os\nimport tempfile\nimport threading\nfrom pathlib import Path\nimport subprocess\nimport xml.etree.ElementTree as ET\n\nimport pyttsx3\nimport speech_recognition as sr\n\n# Try importing enhanced TTS libraries\ntry:\n    import comtypes.client as cc\n    COMTYPES_AVAILABLE = True\nexcept ImportError:\n    COMTYPES_AVAILABLE = False\n\ntry:\n    from TTS.api import TTS as CoquiTTS\n    import torch\n    COQUI_AVAILABLE = True\n    print(\"[TTS] âœ… Coqui TTS available - Ultra-realistic voices enabled\")\nexcept ImportError:\n    COQUI_AVAILABLE = False\n    print(\"[TTS] â„¹ï¸ Coqui TTS not available - using enhanced Windows voices\")\n\n\nclass EnhancedTTS:\n    \"\"\"\n    Enhanced Text-to-Speech with multiple backends for realistic voice synthesis\n    \n    Backends (in order of preference):\n    1. Coqui TTS - Neural voices (most realistic)\n    2. Windows SAPI with SSML - Enhanced expressiveness \n    3. Standard Windows SAPI\n    4. pyttsx3 fallback\n    \"\"\"\n    \n    def __init__(self, voice: Optional[str] = None, rate: int = 170, volume: float = 0.85):\n        self._voice_pref = voice or \"natural\"\n        self._rate = rate\n        self._volume = volume\n        self.temp_dir = Path(tempfile.gettempdir()) / \"jarvis_tts\"\n        self.temp_dir.mkdir(exist_ok=True)\n        \n        # Initialize the best available backend\n        self.backend = \"none\"\n        self.coqui_tts = None\n        self.sapi_voice = None\n        self.pyttsx3_engine = None\n        \n        self._initialize_backends()\n    \n    def _initialize_backends(self) -> None:\n        \"\"\"Initialize TTS backends in order of preference\"\"\"\n        \n        # Try Coqui TTS first (best quality)\n        if COQUI_AVAILABLE and self._voice_pref in [\"neural\", \"coqui\", \"realistic\", \"natural\"]:\n            try:\n                self._init_coqui()\n                if self.coqui_tts:\n                    self.backend = \"coqui\"\n                    print(\"[TTS] ðŸš€ Using Coqui TTS (Neural) - Ultra-realistic voices\")\n                    return\n            except Exception as e:\n                print(f\"[TTS] Coqui TTS init failed: {e}\")\n        \n        # Try Enhanced Windows SAPI with SSML\n        if platform.system() == \"Windows\" and COMTYPES_AVAILABLE:\n            try:\n                self._init_enhanced_sapi()\n                if self.sapi_voice:\n                    self.backend = \"enhanced_sapi\"\n                    print(\"[TTS] ðŸŽ­ Using Enhanced Windows SAPI with expressiveness\")\n                    return\n            except Exception as e:\n                print(f\"[TTS] Enhanced SAPI init failed: {e}\")\n        \n        # Try standard Windows SAPI\n        if platform.system() == \"Windows\" and COMTYPES_AVAILABLE:\n            try:\n                self._init_standard_sapi()\n                if self.sapi_voice:\n                    self.backend = \"sapi\"\n                    print(\"[TTS] ðŸ”Š Using Standard Windows SAPI\")\n                    return\n            except Exception as e:\n                print(f\"[TTS] Standard SAPI init failed: {e}\")\n        \n        # Fallback to pyttsx3\n        try:\n            self._init_pyttsx3()\n            if self.pyttsx3_engine:\n                self.backend = \"pyttsx3\"\n                print(\"[TTS] ðŸ“¢ Using pyttsx3 fallback\")\n        except Exception as e:\n            print(f\"[TTS] pyttsx3 init failed: {e}\")\n            self.backend = \"none\"\n    \n    def _init_coqui(self) -> None:\n        \"\"\"Initialize Coqui TTS with high-quality neural voices\"\"\"\n        try:\n            # Use a fast, high-quality model\n            model_name = \"tts_models/en/ljspeech/tacotron2-DDC\"\n            \n            print(\"[TTS] Initializing Coqui TTS (first run may take time)...\")\n            self.coqui_tts = CoquiTTS(model_name=model_name, gpu=torch.cuda.is_available())\n            \n        except Exception as e:\n            print(f\"[TTS] Coqui TTS initialization failed: {e}\")\n            self.coqui_tts = None\n    \n    def _init_enhanced_sapi(self) -> None:\n        \"\"\"Initialize Windows SAPI with SSML support for expressiveness\"\"\"\n        try:\n            self.sapi_voice = cc.CreateObject(\"SAPI.SpVoice\")\n            \n            # Find and set the best available voice\n            voices = self.sapi_voice.GetVoices()\n            best_voice = self._find_best_voice(voices)\n            \n            if best_voice:\n                self.sapi_voice.Voice = best_voice\n                voice_name = best_voice.GetDescription()\n                print(f\"[TTS] Selected voice: {voice_name}\")\n            \n            # Configure optimal settings\n            self.sapi_voice.Rate = max(-10, min(10, int((self._rate - 200) / 15)))\n            self.sapi_voice.Volume = max(0, min(100, int(self._volume * 100)))\n            \n        except Exception as e:\n            print(f\"[TTS] Enhanced SAPI initialization failed: {e}\")\n            self.sapi_voice = None\n    \n    def _init_standard_sapi(self) -> None:\n        \"\"\"Initialize standard Windows SAPI\"\"\"\n        try:\n            self.sapi_voice = cc.CreateObject(\"SAPI.SpVoice\")\n            \n            # Basic voice configuration\n            if self._voice_pref and self._voice_pref.lower() != \"natural\":\n                voices = self.sapi_voice.GetVoices()\n                for i in range(voices.Count):\n                    voice = voices.Item(i)\n                    if self._voice_pref.lower() in voice.GetDescription().lower():\n                        self.sapi_voice.Voice = voice\n                        break\n            \n            self.sapi_voice.Rate = max(-10, min(10, int((self._rate - 200) / 15)))\n            self.sapi_voice.Volume = max(0, min(100, int(self._volume * 100)))\n            \n        except Exception as e:\n            print(f\"[TTS] Standard SAPI initialization failed: {e}\")\n            self.sapi_voice = None\n    \n    def _init_pyttsx3(self) -> None:\n        \"\"\"Initialize pyttsx3 as final fallback\"\"\"\n        try:\n            if platform.system() == \"Windows\":\n                self.pyttsx3_engine = pyttsx3.init(\"sapi5\")\n            else:\n                self.pyttsx3_engine = pyttsx3.init()\n            \n            if self.pyttsx3_engine:\n                voices = self.pyttsx3_engine.getProperty(\"voices\")\n                if voices:\n                    # Select best voice\n                    best_voice = self._find_best_pyttsx3_voice(voices)\n                    if best_voice:\n                        self.pyttsx3_engine.setProperty(\"voice\", best_voice.id)\n                \n                self.pyttsx3_engine.setProperty(\"rate\", self._rate)\n                self.pyttsx3_engine.setProperty(\"volume\", self._volume)\n        \n        except Exception as e:\n            print(f\"[TTS] pyttsx3 initialization failed: {e}\")\n            self.pyttsx3_engine = None\n    \n    def _find_best_voice(self, voices) -> Optional[any]:\n        \"\"\"Find the best available SAPI voice\"\"\"\n        voice_preferences = [\n            # Prefer these voice names in order\n            [\"zira\", \"female\", \"woman\"],  # Natural female voices\n            [\"david\", \"male\", \"man\"],      # Natural male voices \n            [\"english\", \"en-us\", \"american\"], # English voices\n            [\"desktop\"]  # Desktop voices (usually higher quality)\n        ]\n        \n        try:\n            available_voices = []\n            for i in range(voices.Count):\n                voice = voices.Item(i)\n                name = voice.GetDescription().lower()\n                available_voices.append((voice, name))\n            \n            # Find best match based on preferences\n            for preference_group in voice_preferences:\n                for voice, name in available_voices:\n                    if any(pref in name for pref in preference_group):\n                        return voice\n            \n            # Return first available voice if no preference match\n            if available_voices:\n                return available_voices[0][0]\n                \n        except Exception as e:\n            print(f\"[TTS] Error finding best voice: {e}\")\n        \n        return None\n    \n    def _find_best_pyttsx3_voice(self, voices) -> Optional[any]:\n        \"\"\"Find the best pyttsx3 voice\"\"\"\n        if not voices:\n            return None\n            \n        # Prefer Zira (female) or David (male) if available\n        for voice in voices:\n            name = (voice.name or \"\").lower()\n            if \"zira\" in name or \"english\" in name:\n                return voice\n        \n        # Return first voice as fallback\n        return voices[0]\n    \n    def _create_expressive_ssml(self, text: str) -> str:\n        \"\"\"Create SSML for more expressive speech\"\"\"\n        # Add natural pauses and emphasis\n        enhanced_text = text\n        \n        # Add pauses after punctuation for natural flow\n        enhanced_text = enhanced_text.replace(\".\", \".<break time='300ms'/>\")\n        enhanced_text = enhanced_text.replace(\",\", \",<break time='200ms'/>\")\n        enhanced_text = enhanced_text.replace(\"?\", \"?<break time='400ms'/>\")\n        enhanced_text = enhanced_text.replace(\"!\", \"!<break time='400ms'/>\")\n        \n        # Emphasize J.A.R.V.I.S name\n        enhanced_text = enhanced_text.replace(\"J.A.R.V.I.S\", \"<emphasis level='strong'>J.A.R.V.I.S</emphasis>\")\n        enhanced_text = enhanced_text.replace(\"Jarvis\", \"<emphasis level='moderate'>Jarvis</emphasis>\")\n        \n        # Wrap in SSML\n        ssml = f'<speak version=\"1.0\" xmlns=\"http://www.w3.org/2001/10/synthesis\" xml:lang=\"en-US\">{enhanced_text}</speak>'\n        return ssml\n    \n    def say(self, text: str, wait: bool = True) -> None:\n        \"\"\"Speak text using the best available backend\"\"\"\n        if not text:\n            return\n        \n        print(f\"[TTS] Speaking ({self.backend}): {text[:50]}...\")\n        \n        try:\n            if self.backend == \"coqui\":\n                self._speak_coqui(text)\n            elif self.backend == \"enhanced_sapi\":\n                self._speak_enhanced_sapi(text)\n            elif self.backend == \"sapi\":\n                self._speak_sapi(text)\n            elif self.backend == \"pyttsx3\":\n                self._speak_pyttsx3(text, wait)\n            else:\n                print(\"[TTS] No TTS backend available!\")\n                return\n                \n            print(f\"[TTS] âœ… Speech completed via {self.backend}\")\n            \n        except Exception as e:\n            print(f\"[TTS] âŒ Speech failed: {e}\")\n            # Try fallback\n            self._fallback_speak(text, wait)\n    \n    def _speak_coqui(self, text: str) -> None:\n        \"\"\"Speak using Coqui TTS\"\"\"\n        if not self.coqui_tts:\n            raise Exception(\"Coqui TTS not initialized\")\n        \n        output_path = self.temp_dir / f\"speech_{hash(text) % 1000000}.wav\"\n        \n        # Generate audio\n        self.coqui_tts.tts_to_file(text=text, file_path=str(output_path))\n        \n        # Play audio\n        self._play_audio_file(str(output_path))\n        \n        # Cleanup\n        try:\n            output_path.unlink()\n        except Exception:\n            pass\n    \n    def _speak_enhanced_sapi(self, text: str) -> None:\n        \"\"\"Speak using enhanced SAPI with SSML\"\"\"\n        if not self.sapi_voice:\n            raise Exception(\"Enhanced SAPI not initialized\")\n        \n        # Create expressive SSML\n        ssml_text = self._create_expressive_ssml(text)\n        \n        # Speak with SSML\n        try:\n            self.sapi_voice.Speak(ssml_text, 0)  # Try SSML first\n        except Exception:\n            # Fallback to plain text if SSML fails\n            self.sapi_voice.Speak(text, 0)\n    \n    def _speak_sapi(self, text: str) -> None:\n        \"\"\"Speak using standard SAPI\"\"\"\n        if not self.sapi_voice:\n            raise Exception(\"SAPI not initialized\")\n        \n        self.sapi_voice.Speak(text, 0)\n    \n    def _speak_pyttsx3(self, text: str, wait: bool = True) -> None:\n        \"\"\"Speak using pyttsx3\"\"\"\n        if not self.pyttsx3_engine:\n            raise Exception(\"pyttsx3 not initialized\")\n        \n        self.pyttsx3_engine.stop()\n        self.pyttsx3_engine.say(text)\n        if wait:\n            self.pyttsx3_engine.runAndWait()\n    \n    def _play_audio_file(self, file_path: str) -> None:\n        \"\"\"Play an audio file\"\"\"\n        try:\n            # Try system player first\n            if platform.system() == \"Windows\":\n                subprocess.run([\n                    \"powershell\", \"-c\", \n                    f\"(New-Object Media.SoundPlayer '{file_path}').PlaySync()\"\n                ], check=True, capture_output=True, timeout=30)\n            else:\n                subprocess.run([\"aplay\", file_path], check=True, capture_output=True, timeout=30)\n        except Exception as e:\n            print(f\"[TTS] Audio playback failed: {e}\")\n    \n    def _fallback_speak(self, text: str, wait: bool = True) -> None:\n        \"\"\"Fallback speech method\"\"\"\n        print(\"[TTS] Attempting fallback speech...\")\n        \n        # Try to reinitialize and speak\n        try:\n            if platform.system() == \"Windows\":\n                # Try Windows built-in narrator\n                subprocess.run([\n                    \"powershell\", \"-c\", \n                    f\"Add-Type -AssemblyName System.Speech; (New-Object System.Speech.Synthesis.SpeechSynthesizer).Speak('{text}')\"\n                ], timeout=30)\n                print(\"[TTS] âœ… Fallback speech via PowerShell\")\n            else:\n                print(f\"[TTS] Text: {text}\")\n        except Exception as e:\n            print(f\"[TTS] âŒ All speech methods failed: {e}\")\n            print(f\"[TTS] Text was: {text}\")\n    \n    def get_status(self) -> str:\n        \"\"\"Get current TTS status\"\"\"\n        return f\"Backend: {self.backend}, Voice: {self._voice_pref}, Rate: {self._rate}\"\n    \n    def list_voices(self) -> List[Tuple[str, str]]:\n        \"\"\"List available voices\"\"\"\n        voices = []\n        \n        if self.backend in [\"sapi\", \"enhanced_sapi\"] and self.sapi_voice:\n            try:\n                sapi_voices = self.sapi_voice.GetVoices()\n                for i in range(sapi_voices.Count):\n                    voice = sapi_voices.Item(i)\n                    name = voice.GetDescription()\n                    voices.append((\"sapi\", name))\n            except Exception:\n                pass\n        \n        if self.pyttsx3_engine:\n            try:\n                pyttsx_voices = self.pyttsx3_engine.getProperty(\"voices\")\n                for voice in pyttsx_voices or []:\n                    name = getattr(voice, \"name\", \"Unknown\")\n                    voices.append((\"pyttsx3\", name))\n            except Exception:\n                pass\n        \n        return voices\n\n\n# For backward compatibility, alias the enhanced class\nTTS = EnhancedTTS
